<!-- Based on WebGL Boilerplate by paul irish -->
<!DOCTYPE HTML> 
<html> 
	<head> 
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title>WebGL Boilerplate</title> 
        <link rel="stylesheet" href="assets/app/css/style.css">
        <link rel="stylesheet" href="assets/lib/toastr/css/toastr.css">
		
	</head> 
	<body> 
        <canvas></canvas>
        <div class="code-container">
            <div id="fragment_container" class="container">
                <div id="fragment_label" class="label"><h1>Fragment Shader</h1></div>
                <div id="fragment_editor" class="editor"></div>
            </div> 
            <div id="vertex_container" class="container">
                <div id="vertex_label" class="label"><h1>Vertex Shader</h1></div>
                <div id="vertex_editor" class="editor"></div> 
            </div>
        </div>
        <script>
        
		var triangles = [];
        var vertexBuffer = null;
		var indexBuffer  = null;
		var normalBuffer = null;
        var vertex_position = null;

		var pMatrix = null;
		var vMatrix = null; 
		var mMatrix = null;
		var mMouseX = 0;
		var mMouseY = 0;
		
		var indexCount = 0;
		
        var openGL = null;
        function onInitGL(gl, currentProgram, parameters){

			$('canvas').mousemove(function(e){
				mMouseX = e.offsetX;
				mMouseY = e.offsetY;
				var objPos = {};
				var view = [0, 0, $('canvas').width(), $('canvas').height()];
				GLU.unProject(e.offsetX, e.offsetY, 0, mMatrix, pMatrix, view, objPos);
				
				mMouseX = objPos.x;
				mMouseY = objPos.y;
				console.log(objPos);

			});
			openGL = gl;
			/*
			return new Promise(function(resolve, reject){
				var vertices = [
				  // Front face
				  -1.0, -1.0,  1.0,
				   1.0, -1.0,  1.0,
				   1.0,  1.0,  1.0,
				  -1.0,  1.0,  1.0,
				  
				  // Back face
				  -1.0, -1.0, -1.0,
				  -1.0,  1.0, -1.0,
				   1.0,  1.0, -1.0,
				   1.0, -1.0, -1.0,
				  
				  // Top face
				  -1.0,  1.0, -1.0,
				  -1.0,  1.0,  1.0,
				   1.0,  1.0,  1.0,
				   1.0,  1.0, -1.0,
				  
				  // Bottom face
				  -1.0, -1.0, -1.0,
				   1.0, -1.0, -1.0,
				   1.0, -1.0,  1.0,
				  -1.0, -1.0,  1.0,
				  
				  // Right face
				   1.0, -1.0, -1.0,
				   1.0,  1.0, -1.0,
				   1.0,  1.0,  1.0,
				   1.0, -1.0,  1.0,
				  
				  // Left face
				  -1.0, -1.0, -1.0,
				  -1.0, -1.0,  1.0,
				  -1.0,  1.0,  1.0,
				  -1.0,  1.0, -1.0
				];
			
				var indices = [
					0,  1,  2,      0,  2,  3,    // front
					4,  5,  6,      4,  6,  7,    // back
					8,  9,  10,     8,  10, 11,   // top
					12, 13, 14,     12, 14, 15,   // bottom
					16, 17, 18,     16, 18, 19,   // right
					20, 21, 22,     20, 22, 23    // left
				];
				
										
				for(var i=0; i<vertices.length; i+=3) {
					vertices[i+2] -= 3.0;
				}
			
				vertexBuffer = gl.createBuffer();
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( 
					gl.ARRAY_BUFFER, 
					new Float32Array( vertices ), gl.STATIC_DRAW 
				);

			   
				indexBuffer = gl.createBuffer();
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexBuffer );
				gl.bufferData( 
					gl.ELEMENT_ARRAY_BUFFER, 
					new Uint16Array( indices ), gl.STATIC_DRAW 
				);
				indexCount = indices.length;
				resolve();
				
			});
			*/
			return new Promise(function(resolve, reject){
				var xhttp = new XMLHttpRequest();
				xhttp.onreadystatechange = function(x,y,z) {
					if (xhttp.readyState == 4 && xhttp.status == 200) {
						console.log("loading...");
						var vertices = [];
						var normals  = [];
						var indices  = [];
						var lines = x.currentTarget.responseText.split("\n");
						var bounds = {
							maxX: Number.NEGATIVE_INFINITY,
							maxY: Number.NEGATIVE_INFINITY,
							maxZ: Number.NEGATIVE_INFINITY,
							minX: Number.POSITIVE_INFINITY,
							minY: Number.POSITIVE_INFINITY,
							minZ: Number.POSITIVE_INFINITY
						};
						for(var i=0; i<lines.length; i++) {
							var line = lines[i]
							var components = line.split(',');
							if(components.length == 7) {
								//Vertices have 7 components
								var x  = parseFloat(components[1]);
								var y  = parseFloat(components[2]);
								var z  = parseFloat(components[3]);
								var nx = parseFloat(components[4]);
								var ny = parseFloat(components[5]);
								var nz = parseFloat(components[6]);
								bounds.minX = Math.min(bounds.minX, x);
								bounds.minY = Math.min(bounds.minY, y);
								bounds.minZ = Math.min(bounds.minZ, z);
								bounds.maxX = Math.max(bounds.maxX, x);
								bounds.maxY = Math.max(bounds.maxY, y);
								bounds.maxZ = Math.max(bounds.maxZ, z);
								vertices.push(x, y, z);
								//normals.push(x, y, z);
							} else {
								//Triangles have 4
								var i1 = parseInt(components[1], 10);
								var i2 = parseInt(components[2], 10);
								var i3 = parseInt(components[3], 10);
								indices.push(i1, i2, i3);
								indexCount += 3;
								
								var v1 = [vertices[(i1 * 3)], vertices[(i1 * 3) + 1], vertices[(i1 * 3) + 2]];
								var v2 = [vertices[(i2 * 3)], vertices[(i2 * 3) + 1], vertices[(i2 * 3) + 2]];
								var v3 = [vertices[(i3 * 3)], vertices[(i3 * 3) + 1], vertices[(i3 * 3) + 2]];
								
								var vec1 = vec3.fromValues(v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]);
								var vec2 = vec3.fromValues(v2[0] - v3[0], v2[1] - v3[1], v2[2] - v3[2]);
								
								var normal = vec3.create();
								vec3.cross(normal, vec1, vec2);
								vec3.normalize(normal, normal);
								
								
								triangles.push({
									vertices: [v1, v2, v3],
									normal: normal
								});
							}
						}
						
						//console.log(triangles);
						var dimX = bounds.maxX - bounds.minX;
						var dimY = bounds.maxY - bounds.minY;
						var dimZ = bounds.maxZ - bounds.minZ;

						var transX = -bounds.minX -(dimX / 2);
						var transY = -bounds.minY -(dimY / 2);
						var transZ = -bounds.minZ -(dimZ / 2);
						
						for(var i=0; i<vertices.length; i+=3) {
							vertices[i+0] += transX;
							vertices[i+1] += transY;
							vertices[i+2] += transZ;
						}
						

						
						/*
						normalBuffer = gl.createBuffer();
						gl.bindBuffer( gl.ARRAY_BUFFER, normalBuffer );
						gl.bufferData( 
							gl.ARRAY_BUFFER, 
							new Float32Array( normals ), gl.STATIC_DRAW 
						);
						*/
						
						vertexBuffer = gl.createBuffer();
						gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
						gl.bufferData( 
							gl.ARRAY_BUFFER, 
							new Float32Array( vertices ), gl.STATIC_DRAW 
						);

					   
						indexBuffer = gl.createBuffer();
						gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexBuffer );
						gl.bufferData( 
							gl.ELEMENT_ARRAY_BUFFER, 
							new Uint16Array( indices ), gl.STATIC_DRAW 
						);
						console.log("Done");
						
						resolve()
					}
				};
				xhttp.open("GET", "data/surface_0.txt", true);
				xhttp.send();
			});
        }
        
		function onResize(gl, currentProgram, parameters) {
			mat4.perspective(pMatrix, 90, parameters.screenWidth / parameters.screenHeight, 0.1, 1200.0);
		}
		
		function raycast(origin, direction, center, normal) {
		
			var denom = normal.dot(ray.direction);
			if (Math.abs(denom) > 0.0001) {
				var t = (center - ray.origin).dot(normal) / denom;
				if (t >= 0) {
					return true;
				} 
			}
			return false;
			
		}
		
		isFirstFrame = true;
        function onRenderGL(gl, currentProgram, parameters){
			
			if(isFirstFrame) {
				mat4.translate(mMatrix, mMatrix, vec3.fromValues(0, 0,-140));
				mat4.rotate(mMatrix, mMatrix, 90, vec3.fromValues(-1, 0, 0));
				isFirstFrame = false;
			}
			
			
			var eye     = vec3.fromValues(0.0, 0.0,  0.0);
			var center  = vec3.fromValues(0.0, 0.0, -1.0);
			var up      = vec3.fromValues(0.0, 1.0,  0.0);
			mat4.lookAt(vMatrix, eye, center, up);


			gl.uniformMatrix4fv(gl.getUniformLocation(currentProgram, "matP"), false, pMatrix);
			gl.uniformMatrix4fv(gl.getUniformLocation(currentProgram, "matV"), false, vMatrix);
			gl.uniformMatrix4fv(gl.getUniformLocation(currentProgram, "matM"), false, mMatrix);

			
            gl.uniform2f(
				gl.getUniformLocation(currentProgram, "vecRawMouse"),
				mMouseX,
				mMouseY
			);
			
            //TODO: Put your WebGL Rendering routine here
            gl.uniform1f( 
                gl.getUniformLocation( currentProgram, 'time' ), 
                parameters.time / 1000 
            );
            
            gl.uniform2f( 
                gl.getUniformLocation( currentProgram, 'resolution' ), 
                parameters.screenWidth, parameters.screenHeight
            );

            // Render geometry
			
            gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
			

            gl.vertexAttribPointer( vertex_position, 3, gl.FLOAT, false, 0, 0 );
            gl.enableVertexAttribArray( vertex_position );
			gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);
            gl.disableVertexAttribArray( vertex_position );

        }
        </script>
		
		<script src="assets/lib/ace/js/ace.js" type="text/javascript"></script>
        <script src="assets/lib/jquery/js/jquery.js" type="text/javascript"></script>
        <script src="assets/lib/toastr/js/toastr.js"></script>      
        <script src="assets/lib/gl-matrix/js/gl-matrix.min.js"></script>
        <script src="assets/app/js/main.js" type="text/javascript"></script>
        <script src="assets/app/js/GLU.js" type="text/javascript"></script>
		<script>
			pMatrix = mat4.create();
			vMatrix = mat4.create(); 
			mMatrix = mat4.create();
		</script>
	</body> 
</html>